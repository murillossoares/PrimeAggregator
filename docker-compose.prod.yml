services:
  jupiter-atomic:
    profiles: ["atomic"]
    build:
      context: .
      dockerfile: Dockerfile
    image: prime-aggregator:local
    init: true
    env_file:
      - .env.production
    environment:
      CONFIG_PATH: /app/config.json
      LOG_PATH: /app/logs/events.jupiter.jsonl
      HEALTHCHECK_PORT: "8080"
      BOT_PROFILE: hft
      LOG_VERBOSE: "false"
      EXECUTION_STRATEGY: atomic
      OPENOCEAN_ENABLED: "false"
      JITO_ENABLED: "true"
      JUP_EXECUTION_PROVIDER: "swap"
      JUP_USE_ULTRA: "false"
    volumes:
      - ./config.json:/app/config.json:ro
      - ./logs:/app/logs
    healthcheck:
      test:
        [
          "CMD",
          "node",
          "-e",
          "const http=require('http');const req=http.get('http://127.0.0.1:8080/healthz',res=>process.exit(res.statusCode===200?0:1));req.on('error',()=>process.exit(1));setTimeout(()=>process.exit(1),2000);",
        ]
      interval: 10s
      timeout: 3s
      retries: 3
      start_period: 20s
    restart: unless-stopped
    stop_grace_period: 30s
    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "5"

  jupiter-ultra-sequential:
    profiles: ["ultra"]
    build:
      context: .
      dockerfile: Dockerfile
    image: prime-aggregator:local
    init: true
    env_file:
      - .env.production
    environment:
      CONFIG_PATH: /app/config.json
      LOG_PATH: /app/logs/events.ultra.jsonl
      HEALTHCHECK_PORT: "8080"
      BOT_PROFILE: hft
      LOG_VERBOSE: "false"
      EXECUTION_STRATEGY: sequential
      JUP_EXECUTION_PROVIDER: "ultra"
      JUP_USE_ULTRA: "true"
      OPENOCEAN_ENABLED: "false"
      JITO_ENABLED: "false"
    volumes:
      - ./config.json:/app/config.json:ro
      - ./logs:/app/logs
    healthcheck:
      test:
        [
          "CMD",
          "node",
          "-e",
          "const http=require('http');const req=http.get('http://127.0.0.1:8080/healthz',res=>process.exit(res.statusCode===200?0:1));req.on('error',()=>process.exit(1));setTimeout(()=>process.exit(1),2000);",
        ]
      interval: 10s
      timeout: 3s
      retries: 3
      start_period: 20s
    restart: unless-stopped
    stop_grace_period: 30s
    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "5"

  # Dual mode: scan via Quote API + execute via Ultra, with OpenOcean enabled as a parallel provider.
  # This keeps Ultra requests low (orders only on execution), while still allowing Titan/OpenOcean to win when it's better.
  ultra-dual-sequential:
    profiles: ["dual"]
    build:
      context: .
      dockerfile: Dockerfile
    image: prime-aggregator:local
    init: true
    env_file:
      - .env.production
    environment:
      CONFIG_PATH: /app/config.json
      LOG_PATH: /app/logs/events.dual.jsonl
      HEALTHCHECK_PORT: "8080"
      BOT_PROFILE: hft
      LOG_VERBOSE: "false"
      EXECUTION_STRATEGY: sequential
      JUP_EXECUTION_PROVIDER: "ultra"
      OPENOCEAN_ENABLED: "true"
      OPENOCEAN_MIN_INTERVAL_MS: "1200"
      OPENOCEAN_EVERY_N_TICKS: "2"
      JITO_ENABLED: "false"
    volumes:
      - ./config.json:/app/config.json:ro
      - ./logs:/app/logs
    healthcheck:
      test:
        [
          "CMD",
          "node",
          "-e",
          "const http=require('http');const req=http.get('http://127.0.0.1:8080/healthz',res=>process.exit(res.statusCode===200?0:1));req.on('error',()=>process.exit(1));setTimeout(()=>process.exit(1),2000);",
        ]
      interval: 10s
      timeout: 3s
      retries: 3
      start_period: 20s
    restart: unless-stopped
    stop_grace_period: 30s
    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "5"

  openocean-sequential:
    profiles: ["titan"]
    build:
      context: .
      dockerfile: Dockerfile
    image: prime-aggregator:local
    init: true
    env_file:
      - .env.production
    environment:
      CONFIG_PATH: /app/config.json
      LOG_PATH: /app/logs/events.openocean.jsonl
      HEALTHCHECK_PORT: "8080"
      BOT_PROFILE: hft
      LOG_VERBOSE: "false"
      EXECUTION_STRATEGY: sequential
      PAIR_CONCURRENCY: "1"
      JITO_ENABLED: "false"
      JUP_EXECUTION_PROVIDER: "swap"
      JUP_USE_ULTRA: "false"
      OPENOCEAN_ENABLED: "true"
      OPENOCEAN_ENABLED_DEX_IDS: "10"
      OPENOCEAN_MIN_INTERVAL_MS: "1200"
      OPENOCEAN_EVERY_N_TICKS: "2"
      OPENOCEAN_JUPITER_GATE_BPS: "-50"
    volumes:
      - ./config.json:/app/config.json:ro
      - ./logs:/app/logs
    healthcheck:
      test:
        [
          "CMD",
          "node",
          "-e",
          "const http=require('http');const req=http.get('http://127.0.0.1:8080/healthz',res=>process.exit(res.statusCode===200?0:1));req.on('error',()=>process.exit(1));setTimeout(()=>process.exit(1),2000);",
        ]
      interval: 10s
      timeout: 3s
      retries: 3
      start_period: 20s
    restart: unless-stopped
    stop_grace_period: 30s
    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "5"
